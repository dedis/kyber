package cipher

// State defines an interface to an abstract symmetric message cipher.
// The cipher embodies a secret that may be used to encrypt/decrypt data
// as well as to generate cryptographically random bits.
// The Cipher can also cryptographically absorb data or key material,
// updating its state to produce cryptographic hashes and authenticators.
//
// The main Message method processes a complete message through the Cipher,
// XORing a src byte-slice with cryptographic random bits to yield dst bytes,
// and concurrently absorbing bytes from a key byte-slice into its state:
//
//     cipher.Message(dst, src, key) Cipher
//
// A call always processes exactly max(len(dst),len(dst),len(key)) bytes.
// All slice arguments may be nil or of varying lengths.
// If the src or key slices are short, the missing bytes are taken to be zero.
// If the dst slice is short, the extra output bytes are discarded.
// The src and/or key slices may overlap with dst exactly or not at all.
//
// The cipher preserves and cryptographically accounts for message boundaries,
// so that the following sequence of two calls yields a result
// that is always cryptographically distinct from the above single call.
//
//     cipher.Message(dst[:div], src[:div], key[:div])
//     cipher.Message(dst[div:], src[div:], key[div:])
//
// The cipher guarantees that any key material absorbed during a given call
// will cryptographically affect every bit of all future messages processed,
// but makes no guarantees about whether key material absorbed in this call
// will affect some, all, or none of the cryptographic pseudorandom bits
// produced concurrently in the same call.
//
// A message cipher supports "full-duplex" operation,
// concurrently producing pseudorandom bits and absorbing data,
// supporting efficient use for authenticated encryption.
// This sequence of calls encrypts a plaintext msg to produce a ciphertext ctx
// and an associated message-authenticator mac:
//
//	cipher.Message(ctx, msg, ctx)	// Encrypt and absorb ciphertext
//	cipher.Message(mac, nil, nil)	// Produce MAC based on ciphertext
//
// This encrypts msg into ctx by XORing it with bits generated by the cipher,
// while absorbing the output ciphertext into the cipher's state.
// The second Message call then uses the resulting state to produce a MAC.
//
// The following sequence decrypts and verifies a received ciphertext and MAC
// encrypted in the above fashion:
//
//	cipher.Message(msg, ctx, ctx)	// Decrypt and absorb ciphertext
//	cipher.Message(mac, mac, nil)	// Compute MAC and XOR with received
//	valid := subtle.ConstantTimeAllEq(mac, 0)
//
// This decrypts ctx into msg by XORing the same bits used during encryption,
// while similarly absorbing the ciphertext (which is the input this time).
// The second Message call recomputes the MAC based on the absorbed ciphertext,
// XORs the recomputed MAC onto the received MAC in-place,
// and verifies in constant time that the result is zero
// (i.e., that the received and recomputed MACs are equal).
//
// The Cipher wrapper provides convenient Seal and Open functions
// performing the above authenticated encryption sequences.
//
// A cipher may be operated as a cryptographic hash function taking
// messsage msg and producing cryptographic checksum in slice sum:
//
//	cipher.Message(nil, nil, msg)	// Absorb msg into Cipher state
//	cipher.Message(sum, nil, nil)	// Produce cryptographic hash in sum
//
// Both the input msg and output sum may be of any length,
// and the Cipher guarantees that every bit of the output sum has a
// strong cryptographic dependency on every bit of the input msg.
// However, to achieve full security, the caller should ensure that
// the output sum is at least cipher.HashSize() bytes long.
//
// The Partial method processes a partial (initial or continuing) portion
// of a message, allowing the Cipher to be used for byte-granularity streaming:
//
//	cipher.Partial(dst, src, key)
//
// The above single call is thus equivalent to the following pair of calls:
//
//	cipher.Partial(dst[:div], src[:div], key[:div])
//	cipher.Partial(dst[div:], src[div:], key[div:])
//
// One or more calls to Partial must be terminated with a call to Message,
// to complete the message and ensure that key-material bytes absorbed
// in the current message affect the pseudorandom bits the Cipher produces
// in the context of the next message.
// Key material absorbed in a given Partial call may, or may not,
// affect the pseudorandom bits generated in subsequent Partial calls
// if there are no intervening calls to Message.
//
// A Cipher may be used to generate pseudorandom bits that depend
// only on the Cipher's initial state in the following fashion:
//
//	cipher.Partial(dst, nil, nil)
//
// XXX move this to cipher package?
type State interface {

	// Transform a message (or the final portion of one) from src to dst,
	// absorb key into the cipher state, and return the Cipher.
	Message(dst, src, key []byte)

	// Transform a partial, incomplete message from src to dst,
	// absorb key into the cipher state, and return the Cipher.
	Partial(dst, src, key []byte)

	// Return the minimum size in bytes of secret keys for full security
	// (although key material may be of any size).
	KeySize() int

	// Return recommended size in bytes of hashes for full security.
	// This is usually 2*KeySize() to account for birthday attacks.
	HashSize() int

	// Create an identical clone of this cryptographic state object.
	// Caution: misuse can lead to key-reuse vulnerabilities.
	Clone() State
}

// Suite represents a constructor for symmetric-key message cipher instances.
type Suite interface {

	// Create a message cipher state with a given key and configuration.
	// If key is nil, creates a state seeded with a fresh random key.
	Cipher(key []byte) State
}

// HashSuite is an optional extension to Suite
// allowing a ciphersuite to implement a specialized hash algorithm
// in place of a generic one based on the message cipher.
type HashSuite interface {
	Suite

	// Construct a symmetric-key hash function.
	Hash(key []byte) Hash
}

// HashSuite is an optional extension to Suite
// allowing a ciphersuite to implement a specialized hash algorithm
// in place of a generic one based on the message cipher.
type StreamSuite interface {
	Suite

	// Symmetric-key stream cipher
	Stream(key []byte) Stream
}

// Pass NoKey to a cipher Suite constructor to create an unkeyed cipher.
var NoKey = []byte{}

// Pass FreshKey to a Suite constructor to create a freshly seeded cipher.
var FreshKey []byte = nil
